<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>7장 - 오류 처리</title>
        <meta name="description" content="7장 - 오류 처리 프로그램은 입력이 이상하거나, 기기에 문제가 생기는 등 뭔가 잘못될 가능성이 항상 존재한다. 따라서 프로그래머는 그 상황을 바로 잡을 책임이 있다. 하지만 흩어진 오류 처리 코드는 코드의 가독성을 낮출 수 있기에, 우아하고 고상하게 오류를 처리할 필요가 있다.오류 코드보다 예외를 사용하라 class DeviceController {   ..." />
        <meta name="author" content="Marshall Ku" />
        <meta name="robots" content="index,follow" />
        <meta property="og:type" content="article" />
        <meta property="og:site_name" content="클린 코드 스터디" />
        <meta property="og:title" content="7장 - 오류 처리" />
        <meta property="og:description" content="7장 - 오류 처리 프로그램은 입력이 이상하거나, 기기에 문제가 생기는 등 뭔가 잘못될 가능성이 항상 존재한다. 따라서 프로그래머는 그 상황을 바로 잡을 책임이 있다. 하지만 흩어진 오류 처리 코드는 코드의 가독성을 낮출 수 있기에, 우아하고 고상하게 오류를 처리할 필요가 있다.오류 코드보다 예외를 사용하라 class DeviceController {   ..." />
        <meta name="twitter:title" content="7장 - 오류 처리" />
        <meta name="twitter:description" content="7장 - 오류 처리 프로그램은 입력이 이상하거나, 기기에 문제가 생기는 등 뭔가 잘못될 가능성이 항상 존재한다. 따라서 프로그래머는 그 상황을 바로 잡을 책임이 있다. 하지만 흩어진 오류 처리 코드는 코드의 가독성을 낮출 수 있기에, 우아하고 고상하게 오류를 처리할 필요가 있다.오류 코드보다 예외를 사용하라 class DeviceController {   ..." />
        <meta property="article:published_time" content="2022-04-23T08:26:00.000Z" />
        <meta property="og:regDate" content="2022-04-23T08:26:00.000Z" />
        <meta property="article:modified_time" content="2022-04-23T08:26:00.000Z" />
        <meta property="og:updated_time" content="2022-04-23T08:26:00.000Z" />
        <link rel="preconnect" async href="https://fonts.googleapis.com" />
        <link
            rel="preconnect"
            async
            href="https://fonts.gstatic.com"
            crossorigin
        />
        <link
            async
            href="https://fonts.googleapis.com/css2?family=Anonymous+Pro:ital@0;1&family=Nanum+Gothic+Coding&family=Noto+Sans+KR:wght@400;700&display=swap"
            rel="stylesheet"
        />
        <link rel="stylesheet" async href="/Clean-Code/css/reset.css" />
        <link rel="stylesheet" async href="/Clean-Code/css/icon.css" />
        <link rel="stylesheet" async href="/Clean-Code/css/style.css" />
        <style>
            @font-face {
                font-family: icon;
                src: url("/Clean-Code/icon/icon.woff?zg8y3j") format("woff"),
                    url("/Clean-Code/icon/icon.svg?zg8y3j#icon") format("svg");
                font-weight: 400;
                font-style: normal;
                font-display: block;
            }
        </style>
        <link
            rel="icon"
            type="image/png"
            sizes="32x32"
            href="/Clean-Code/favicon-32x32.png"
        />
        <link
            rel="icon"
            type="image/png"
            sizes="96x96"
            href="/Clean-Code/favicon-96x96.png"
        />
        <link
            rel="icon"
            type="image/png"
            sizes="16x16"
            href="/Clean-Code/favicon-16x16.png"
        />
    </head>
    <body>
        <nav class="global-navigation">
            <div class="global-navigation__content">
                <ul><li><a href="/Clean-Code/">클린 코드 스터디</a></li><li><a href="/Clean-Code/1%EC%9E%A5%20-%20%EA%B9%A8%EB%81%97%ED%95%9C%20%EC%BD%94%EB%93%9C/">1장 - 깨끗한 코드</a></li$><li><a href="/Clean-Code/2%EC%9E%A5%20-%20%EC%9D%98%EB%AF%B8%20%EC%9E%88%EB%8A%94%20%EC%9D%B4%EB%A6%84/">2장 - 의미 있는 이름</a></li$><li><a href="/Clean-Code/3%EC%9E%A5%20-%20%ED%95%A8%EC%88%98/">3장 - 함수</a></li$><li><a href="/Clean-Code/6%EC%9E%A5%20-%20%EA%B0%9D%EC%B2%B4%EC%99%80%20%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">6장 - 객체와 자료구조</a></li$><li class="highlight"><a href="/Clean-Code/7%EC%9E%A5%20-%20%EC%98%A4%EB%A5%98%20%EC%B2%98%EB%A6%AC/">7장 - 오류 처리</a></li$><li><a href="/Clean-Code/8%EC%9E%A5%20-%20%EA%B2%BD%EA%B3%84/">8장 - 경계</a></li$><li><a href="/Clean-Code/9%EC%9E%A5%20-%20%EB%8B%A8%EC%9C%84%20%ED%85%8C%EC%8A%A4%ED%8A%B8/">9장 - 단위 테스트</a></li$><li><a href="/Clean-Code/10%EC%9E%A5%20-%20%ED%81%B4%EB%9E%98%EC%8A%A4/">10장 - 클래스</a></li$><li><a href="/Clean-Code/11%EC%9E%A5%20-%20%EC%8B%9C%EC%8A%A4%ED%85%9C/">11장 - 시스템</a></li$><li><a href="/Clean-Code/12%EC%9E%A5%20-%20%EC%B0%BD%EB%B0%9C%EC%84%B1/">12장 - 창발성</a></li$><li><a href="/Clean-Code/13%EC%9E%A5-%20%EB%8F%99%EC%8B%9C%EC%84%B1/">13장- 동시성</a></li$></ul>
            </div>
        </nav>
        <main>
            <article class="article">
                <!--
author: Marshall Ku
-->
<h1 id="7장---오류-처리">7장 - 오류 처리</h1>
<p>프로그램은 입력이 이상하거나, 기기에 문제가 생기는 등 뭔가 잘못될 가능성이 항상 존재한다. 따라서 프로그래머는 그 상황을 바로 잡을 책임이 있다.</p>
<p>하지만 흩어진 오류 처리 코드는 코드의 가독성을 낮출 수 있기에, <strong>우아하고 고상하게</strong> 오류를 처리할 필요가 있다.</p><h2 id="오류-코드보다-예외를-사용하라">오류 코드보다 예외를 사용하라</h2>
<pre><code class="language-ts">class DeviceController {
    // ...
    sendShutdown(): void {
        const handle: DeviceHandle = getHandle(DEV1);

        // 기기 상태 점검
        if (handle !== DeviceHandle.INVALID) {
            // 레코드 필드에 기기 상태 저장
            retrieveDeviceRecord(handle);

            // 기기가 일시 정지 상태가 아니면 종료
            if (record.getStatus() !== DEVICE_SUSPENDED) {
                pauseDevice(handle);
                clearDeviceWorkQueue(handle);
                closeDevice(handle);
            } else {
                logger.error("Device suspended. Unable to shut down");
            }
        } else {
            logger.error(`Invalid handle for: ${DEV1.toString()}`);
        }
    }
}
</code></pre>
<p>오류 플래그를 설정하거나 호출자에게 오류 코드를 반환하는 방법은 함수를 호출한 즉시 오류를 확인해야 하기 때문에 호출자 코드를 복잡하게 만든다. 심지어 이 단계를 잊어버리기도 쉽다.</p>
<pre><code class="language-ts">class DeviceController {
    // ...
    sendShutdown(): void {
        try {
            tryToShutDown();
        } catch (error) {
            logger.error(error);
        }
    }

    tryToShutdown(): void {
        const handle: DeviceHandle = getHandle(DEV1);
        const record: DeviceRecord = retrieveDeviceRecord(handle);

        pauseDevice(handle);
        clearDeviceWorkQueue(handle);
        closeDevice(handle);
    }

    getHandle(id: DeviceId): void {
        // ...
        throw new Error(`Invalid handle for: ${id.toString()}`);
        // ...
    }
    // ...
}
</code></pre>
<p>오류가 발생했을 때 오류를 던지면 논리와 오류 처리 코드가 뒤섞이지 않아 호출자 코드를 깔끔하게 유지할 수 있다.</p>
<p>위 예시에선 디바이스를 종료하는 알고리즘과 오류를 처리하는 알고리즘을 분리해 각 개념을 독립적으로 살펴볼 수 있도록 리팩터링했다.</p>
<h2 id="try-catch-finally-문부터-작성하라">Try-Catch-Finally 문부터 작성하라</h2>
<p>예외에서 프로그램 안에다 <strong>범위를 정의한다</strong>는 사실은 매우 흥미롭다. try 블록에 들어가는 코드를 실행하면 어느 시점에서든 실행이 중단되고 catch 블록으로 넘어갈 수 있다.</p>
<p>어떤 면에서 try 블록은 트랜잭션과 비슷하다. try 블록에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일관성 있게 유지해야 한다. 그러므로 에 외가 발생할 코드를 짤 때는 try-catch-finally 문으로 시작하는 편이 낫다. 그러면 try 블록에서 무슨 일이 생기든지 호출자가 기대 상태를 정의하기 쉬워진다.</p>
<pre><code class="language-js">it("Retrieve section should throw on invalid file name", () => {
    expect(() => {
        retrieveSection("invalid - file");
    }).toThrow();
});
</code></pre>
<p>파일을 열어 직렬화된 객체 몇 개를 읽어 들이는 코드를 구현하기 위해 단위 테스트를 구현했다.</p>
<pre><code class="language-ts">function retrieveSection(sectionName: string): RecordedGrip {
    return [] as RecordedGrip;
}
</code></pre>
<p>단위 테스트에 맞춰 위 코드를 구현했으나, 오류를 던지지 않으므로 단위 테스트는 실패한다.</p>
<pre><code class="language-ts">function retrieveSection(sectionName: string): RecordedGrip {
    try {
        const stream = fs.openSync(sectionName);
    } catch (e) {
        throw new Error("retrieval error");
    }

    return [] as RecordedGrip;
}
</code></pre>
<p>잘못된 파일 접근을 시도하여, 오류를 던지도록 구현을 변경했다. 이제 테스트가 성공하고, 이 시점에서 리팩터링이 가능하다.</p>
<pre><code class="language-ts">function retrieveSection(sectionName: string): RecordedGrip {
    try {
        const stream = fs.openSync(sectionName);
        fs.closeSync(stream);
    } catch (e) {
        throw new Error("retrieval error");
    }

    return [] as RecordedGrip;
}
</code></pre>
<p>try-catch 구조로 범위를 정의했으므로 TDD를 사용해 필요한 나머지 논리를 추가한다. 나머지 논리는 <code>openSync</code>와 <code>closeSync</code> 사이에 넣으며, 오류나 예외가 전혀 발생하지 않는다고 가정한다.</p>
<p>먼저 강제로 오류를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장한다. 그러면 자연스럽게 try 블록의 트랜잭션 범위부터 구현하게 되므로 범위 내에서 트랜잭션 본질을 유지하기 쉬워진다.</p>
<h2 id="예외에-의미를-제공하라">예외에 의미를 제공하라</h2>
<p>오류를 던질 때는 전후 상황을 충분히 덧붙여 오류가 발생한 원인과 위치를 찾기 쉽도록 하자. 자바스크립트는 모든 오류에 호출 스택을 제공하긴 하지만, 실패한 코드의 의도를 파악하기엔 호출 스택으론 역부족이다.</p>
<p>오류 메시지에 실패한 연산 이름, 실패 유형 등을 담아 던지도록 하자.</p>
<pre><code class="language-js">const images = [
    "https://i.imgur.com/pnEPoyq.gif",
    "https://i.imgur.com/3K3TIIS.gif",
    "https://i.imgur.com/PfJXwd8.gif",
    "https://i.imgur.com/Bra4jgp.gif",
    "https://i.imgur.com/v0qRJlZ.gif",
    "https://i.imgur.com/EPWdCbp.gif",
];

const imagesWithError = [
    "https://i.imgur.com/pnEPoyq_invalid.gif",
    "https://i.imgur.com/3K3TIIS_invalid.gif",
    "https://i.imgur.com/PfJXwd8_invalid.gif",
    "https://i.imgur.com/Bra4jgp_invalid.gif",
    "https://i.imgur.com/v0qRJlZ_invalid.gif",
    "https://i.imgur.com/EPWdCbp_invalid.gif",
];

function loadImage(src) {
    return new Promise((resolve, reject) => {
        const image = new Image();

        image.src = src;

        image.addEventListener(
            "load",
            () => {
                resolve(image);
            },
            { once: true },
        );

        image.addEventListener(
            "error",
            () => {
                reject(new Error(`Invalid image: ${src}`));
            },
            { once: true },
        );
    });
}

function main() {
    Promise.all(images.map(loadImage)).then((result) => {
        console.log(result);
    });

    Promise.all(imagesWithError.map(loadImage)).then((result) => {
        console.log(result);
    });
}

main();
</code></pre>
<p><img src="/Clean-Code/images/promise_error.png" alt="Promise 오류"></p>
<p>비동기적인 처리 중 오류가 발생하면 스택이 사라지던 시절이 있었으나, 다행히도 이젠 옛말이 되었다.<br>
<code>throw</code>나 <code>reject</code>에 <code>Error</code> 객체 외의 것을 사용하면 여전히 스택이 사라질 수 있으니, 항상 <code>Error</code> 객체를 사용하는 것만 유념하도록 하자.</p>
<h2 id="정상-흐름을-정의하라">정상 흐름을 정의하라</h2>
<p>비즈니스 논리와 오류 처리를 잘 분리해 코드를 작성하면 코드 대부분이 깨끗하고 간결한 알고리즘으로 보이기 시작한다. 하지만 그러다 보면 오류 감지가 프로그램 언저리로 밀려난다.</p>
<p>때로는 오류를 던지고 중단된 계산을 처리하는 게 적합하지 않을 때도 있다.</p>
<pre><code class="language-ts">try {
    const expenses: MealExpenses = expenseReportDAO.getMeals(employee.getId());
    total += expenses.getTotal();
} catch (error) {
    total += getMealPerDiem();
}
</code></pre>
<p>식비를 비용으로 청구했다면 청구한 식비를 총계에 더하고, 청구하지 않았다면 일일 기본 식비를 더하는 코드이다. 간단한 코드이지만, try-catch 문이 논리를 따라가기 어렵게 만든다.</p>
<pre><code class="language-ts">const expenses: MealExpenses = expenseReportDAO.getMeals(employee.getID());
total += expenses.getTotal();
</code></pre>
<p><code>expenseReportDAO</code>를 수정해 식비를 청구하지 않았을 때도 일일 기본 식비를 반환하는 <code>MealExpense</code> 객체를 반환하면 예외처리 없이 간결한 코드가 완성된다.</p>
<p>이를 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 특수 사례 패턴<sup>Special Case Pattern</sup><sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref aria-describedby="footnote-label">1</a></sup>이라 부른다. 이 패턴을 사용하면 클래스나 객체가 예외적인 상황을 캡슐화해서 처리하기에 클라이언트 코드가 예외적인 상황을 처리할 필요가 없어진다.</p>
<h2 id="null을-반환하거나-전달하지-마라">null을 반환하거나 전달하지 마라</h2>
<h3 id="null의-반환">null의 반환</h3>
<pre><code class="language-ts">function registerItem(item: Item) {
    if (item !== null) {
        const registry: ItemRegistry = persistentStore.getItemRegistry();

        if (registry !== null) {
            const existing: Item = registry.getItem(item.getId());

            if (existing.getBillingPeriod().hasRetailOwner()) {
                existing.register(item);
            }
        }
    }
}
</code></pre>
<p><code>null</code>을 반환하는 코드는 일거리를 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다. <code>null</code> 확인을 빼먹는 순간 애플리케이션이 정지되거나, 혹은 더 안 좋은 상황에 부닥치게 될지도 모른다.</p>
<p>위 코드에서도 <code>persistentStore</code>에 관한 <code>null</code> 확인이 빠져있는데, 코드를 읽으며 눈치챘는가? 애플리케이션 저 아래서 날린 null pointer exception을 처리하기란 쉽지 않다.<br>
이렇게 말하면 <code>null</code> 확인이 누락된 문제라 이해하기 쉬우나, <code>null</code> 확인이 <strong>너무 많아</strong> 나쁜 코드다. <code>null</code>을 반환하고 싶을 땐 예외를 던지거나 상술한 특수 사례 패턴을 사용해보자.</p>
<hr>
<p>JavaScript엔 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">Optional Chaining</a>이 있으니 이것도 확인해보자.</p>
<pre><code class="language-js">const registry: ItemRegistry = persistentStore?.getItemRegistry();
</code></pre>
<p>위와 같이 작성하면 <code>persistentStore.getItemRegistry</code>와 유사하게 작동하나, 참조가 <code>nullish</code>일 때 에러가 발생하지 않고 표현식의 반환 값을 <code>undefined</code>로 단락한다.</p>
<h3 id="null의-전달">null의 전달</h3>
<p>정상적인 인수로 <code>null</code>을 기대하는 API가 아니라면 <code>null</code>을 전달하는 코드는 최대한 피하도록 하자.</p>
<pre><code class="language-ts">function calculateDistance(p1: Point, p2: Point): number {
    return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}
</code></pre>
<p>위 코드는 좌표평면에서 두 점 사이의 거리를 구하는 간단한 함수다.<br>
만약 <code>Point</code> 타입이 <code>nullish</code>일 수 있다면 위 코드는 오류가 발생하게 된다.</p>
<pre><code class="language-ts">function calculateDistance(p1: Point, p2: Point): number {
    if (!p1 || !p2) {
        throw new Error("Invalid argument for calculateDistance");
    }

    return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}
</code></pre>
<p>과연 이렇게 <code>nullish</code>를 확인하는 코드가 나을까?</p>
<p>대다수 프로그래밍 언어는 호출자가 실수로 넘긴 <code>null</code>을 적절히 처리하는 방법이 없다. 애초에 <code>null</code>을 넘기지 못하도록 하면 인수로 <code>null</code>이 넘어오면 코드에 문제가 있다는 말이 된다. 이런 정책은 부주의한 실수를 저지를 확률을 낮춰준다.</p>
<h3 id="nodeback-스타일-콜백">NodeBack 스타일 콜백</h3>
<pre><code class="language-js">if (callback) {
    if (success) {
        callback(null, value);
    } else {
        callback(error, null);
    }
}
</code></pre>
<p><code>null</code>의 반환과 전달 모두 바람직하지 않단 건 알겠으나, 어디에나 예외는 있는 법이다.<br>
NodeBack 스타일에선 에러를 <code>null</code>로 전달하는 관습이 있다. 상황과 표준에 맞게 유연하게 작업하도록 하자.</p>
<h2 id="null을-전달하지-마라">null을 전달하지 마라</h2>
<h2 id="결론">결론</h2>
<p>'읽기 좋은 코드'와 '안정성 높은 코드'는 상충하는 목표가 아니다. 깨끗한 코드는 가독성뿐 아니라 안정성도 높아야 한다. 오류 처리를 프로그램 논리와 분리해 깨끗한 코드를 작성하도록 하자.</p>
<section data-footnotes class="footnotes"><h2 id="footnote-label" class="sr-only">Footnotes</h2>
<ol>
<li id="user-content-fn-1">
<p><a href="https://martinfowler.com/eaaCatalog/specialCase.html">https://martinfowler.com/eaaCatalog/specialCase.html</a> <a href="#user-content-fnref-1" data-footnote-backref class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
</ol>
</section><div class="navigation"><article class="navigation-item navigation-item--previous"><a href="/Clean-Code/6장 - 객체와 자료구조/"><div><div class="navigation-item__type">Previous</div><h2 class="navigation-item__title">6장 - 객체와 자료구조</h2></div><div><i class="icon-arrow_back"></i></div></a></article><article class="navigation-item navigation-item--next"><a href="/Clean-Code/8장 - 경계/"><div><div class="navigation-item__type">Next</div><h2 class="navigation-item__title">8장 - 경계</h2></div><div><i class="icon-arrow_forward"></i></div></a></article></div>
            </article>
            <div class="toc-container"><ul class="toc"><li><p><a href="#%EC%98%A4%EB%A5%98-%EC%BD%94%EB%93%9C%EB%B3%B4%EB%8B%A4-%EC%98%88%EC%99%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC">오류 코드보다 예외를 사용하라</a></p></li><li><p><a href="#try-catch-finally-%EB%AC%B8%EB%B6%80%ED%84%B0-%EC%9E%91%EC%84%B1%ED%95%98%EB%9D%BC">Try-Catch-Finally 문부터 작성하라</a></p></li><li><p><a href="#%EC%98%88%EC%99%B8%EC%97%90-%EC%9D%98%EB%AF%B8%EB%A5%BC-%EC%A0%9C%EA%B3%B5%ED%95%98%EB%9D%BC">예외에 의미를 제공하라</a></p></li><li><p><a href="#%EC%A0%95%EC%83%81-%ED%9D%90%EB%A6%84%EC%9D%84-%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC">정상 흐름을 정의하라</a></p></li><li><p><a href="#null%EC%9D%84-%EB%B0%98%ED%99%98%ED%95%98%EA%B1%B0%EB%82%98-%EC%A0%84%EB%8B%AC%ED%95%98%EC%A7%80-%EB%A7%88%EB%9D%BC">null을 반환하거나 전달하지 마라</a></p><ul><li><a href="#null%EC%9D%98-%EB%B0%98%ED%99%98">null의 반환</a></li><li><a href="#null%EC%9D%98-%EC%A0%84%EB%8B%AC">null의 전달</a></li><li><a href="#nodeback-%EC%8A%A4%ED%83%80%EC%9D%BC-%EC%BD%9C%EB%B0%B1">NodeBack 스타일 콜백</a></li></ul></li><li><p><a href="#null%EC%9D%84-%EC%A0%84%EB%8B%AC%ED%95%98%EC%A7%80-%EB%A7%88%EB%9D%BC">null을 전달하지 마라</a></p></li><li><p><a href="#%EA%B2%B0%EB%A1%A0">결론</a></p></li></ul></div>
        </main>
        <button class="drawer-opener icon-menu" aria-label="메뉴 보기"></button>
        <button
            class="toc-opener icon-bookmark_outline"
            aria-label="목차 보기"
        ></button>
        <button class="closer"></button>
        <script
            defer
            src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/highlight.min.js"
        ></script>
        <script defer src="/Clean-Code/js/app.js"></script>
    </body>
</html>
